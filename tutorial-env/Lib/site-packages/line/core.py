import re
import time
import json
import random

import pyee
import requests

from line.logger import logger
from line.exceptions import BotNotExistsException, BotNotFoundException, InvalidTokenException


class Line:

    def __init__(self, authentication, bot=None, client_type="PC", device_type="",
                 ping_secs=60, streaming_token_retries=1):

        if not isinstance(client_type, str):
            raise TypeError("client_type must be a str.")

        if not isinstance(device_type, str):
            raise TypeError("device_type must be a str.")

        if not isinstance(ping_secs, int):
            raise TypeError("ping_secs must be a int.")

        if not isinstance(streaming_token_retries, int):
            raise TypeError("streaming_token_retries must be a int.")

        self.HOST = "https://chat.line.biz"
        self.__x_oa_chat_client_version = "20230404142351"
        self.client_type = client_type
        self.device_type = device_type
        self.ping_secs = ping_secs
        self.streaming_token_retries = streaming_token_retries

        self.session = self._make_session(authentication.login())
        self.account = self.me()

        if bot is not None:
            self.bot = self.select_bot(bot)
        else:
            bots = self.bots()
            if not bots["list"]:
                raise BotNotExistsException

            self.bot = bots["list"][0]

        self.bot_id = self.bot["botId"]
        self.event_funcs = {"event": []}
        self.event_emitter = pyee.executor.ExecutorEventEmitter()

    def select_bot(self, name):
        bots = self.bots()
        try:
            for bot in bots["list"]:
                if bot["name"] == name:
                    return bot
        except KeyError as e:
            logger.error(bots)
            raise e
        raise BotNotFoundException(bots)

    @classmethod
    def extract_emojis(cls, raw_text):
        pattern = "\[EM:([\w\d]+),id=([\w\d]+)\]"
        emojis = []
        gap = 0
        for match in re.finditer(pattern, raw_text):
            product_id = match.group(1)
            emoji_id = match.group(2)
            start = match.start()
            end = match.end()
            index = start - gap
            gap += end - start - 1
            emojis.append({
                "productId": product_id,
                "emojiId": emoji_id,
                "length": 1,
                "index": index
            })
        return emojis or None

    def _make_session(self, data):
        headers = {
            "x-oa-chat-client-version": self.__x_oa_chat_client_version,
            "x-xsrf-token": data["xsrf_token"]
        }
        cookies = {
            "XSRF-TOKEN": data["xsrf_token"],
            "ses": data["ses"]
        }
        session = requests.Session()
        session.headers.update(headers)
        session.cookies.update(cookies)
        return session

    def csrf_token(self):
        """获取X-XSRF-TOKEN"""
        url = "https://chat.line.biz/api/v1/csrfToken"
        response = self.session.get(url)
        return response.json()

    def streaming_api_token(self):
        """获取streamingApiToken"""
        url = f"https://chat.line.biz/api/v1/bots/{self.bot_id}/streamingApiToken"
        response = self.session.post(url)
        return response.json()

    def state(self, connection_id, idle):
        """修改连接状态"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/streaming/state"
        data = {"connectionId": connection_id, "idle": idle}
        response = self.session.put(url, json=data)
        return response.json()

    def me(self):
        """账号信息"""
        url = self.HOST + "/api/v1/me"
        response = self.session.get(url)
        return response.json()

    def settings_call(self):
        """呼叫设置信息"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/settings/call"
        response = self.session.get(url)
        return response.json()

    def settings_reservation(self):
        """预约设置信息"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/settings/reservation"
        response = self.session.get(url)
        return response.json()

    def chat_mode(self):
        """聊天模式"""
        url = self.HOST + f"/api/v3/bots/{self.bot_id}/settings/chatMode"
        response = self.session.get(url)
        return response.json()

    def chat_mode_scheduler(self):
        """聊天模式日程"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/settings/chatModeSchedules"
        response = self.session.get(url)
        return response.json()

    def settings_pc(self):
        """PC端设置信息"""
        url = self.HOST + f"/api/v1/me/settings/pc"
        response = self.session.get(url)
        return response.json()

    def available_features(self):
        """可用特性"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/availableFeatures"
        response = self.session.get(url)
        return response.json()

    def banner_web(self):
        """web端广告"""
        url = self.HOST + f"/api/v2/bots/{self.bot_id}/banner/web"
        response = self.session.get(url)
        return response.json()

    def owners(self):
        """机器人拥有者"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/owners"
        response = self.session.get(url)
        return response.json()

    def search_limitation_stats(self):
        """搜索限制统计"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/searchLimitationStats"
        response = self.session.get(url)
        return response.json()

    def whitelist_domains(self):
        """白名单域名"""
        url = self.HOST + "/api/v1/whitelistDomains"
        response = self.session.get(url)
        return response.json()

    def tags(self):
        """标签列表"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/tags"
        response = self.session.get(url)
        return response.json()

    def add_tag(self, name):
        """添加标签"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/tags"
        data = {
            "name": name
        }
        response = self.session.post(url, json=data)
        return response.json()

    def get_tag(self, tag_id):
        """标签详情"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/tags/{tag_id}"
        response = self.session.get(url)
        return response.json()

    def auto_tags(self):
        """自动标签列表"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/autoTags"
        response = self.session.get(url)
        return response.json()

    def now(self):
        """服务器时间"""
        url = self.HOST + "/api/v1/clock/now"
        response = self.session.get(url)
        return response.json()

    def bots(self, no_filter=True, limit=1000):
        """机器人列表"""
        url = self.HOST + "/api/v1/bots"
        params = {
            "noFilter": no_filter,
            "limit": limit
        }
        response = self.session.get(url, params=params)
        return response.json()

    def contacts(self, query="", next="", sort_key="DISPLAY_NAME", sort_order="ASC", exclude_spam=True, limit=20):
        """查询联系人"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/contacts"
        params = {
            "query": query,
            "sortKey": sort_key,
            "sortOrder": sort_order,
            "excludeSpam": exclude_spam,
            "next": next,
            "limit": limit
        }
        response = self.session.get(url, params=params)
        return response.json()

    def messages(self, contact_id, backward=""):
        """查询聊天记录"""
        url = self.HOST + f"/api/v2/bots/{self.bot_id}/messages/{contact_id}"
        params = {
            "backward": backward
        }
        response = self.session.get(url, params=params)
        return response.json()

    def chats(self, folder_type="ALL", tag_ids="", auto_tag_ids="", limit=25, next="", prioritize_pinned_chat=True):
        """查询会话列表"""
        url = self.HOST + f"/api/v2/bots/{self.bot_id}/chats"
        params = {
            "folderType": folder_type,
            "tagIds": tag_ids,
            "autoTagIds": auto_tag_ids,
            "limit": limit,
            "next": next,
            "prioritizePinnedChat": prioritize_pinned_chat
        }
        response = self.session.get(url, params=params)
        return response.json()

    def delete_chat(self, contact_id):
        """删除会话"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}"
        response = self.session.delete(url)
        return response.json()

    def add_mute_chat(self, contact_id):
        """禁用会话声音"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/mute/pc"
        response = self.session.put(url)
        return response.json()

    def delete_mute_chat(self, contact_id):
        """禁用会话声音"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/mute/pc"
        response = self.session.delete(url)
        return response.json()

    def set_use_manual_chat(self, contact_id):
        """设置手动聊天模式"""
        url = self.HOST + f"/api/v2/bots/{self.bot_id}/chats/{contact_id}/useManualChat"
        data = {
            "expiresAt": int(time.time() * 1000) + 3600
        }
        response = self.session.put(url, json=data)
        return response.json()

    def get_use_manual_chat(self, contact_id):
        """查询手动聊天模式"""
        url = self.HOST + f"/api/v2/bots/{self.bot_id}/chats/{contact_id}/useManualChat"
        response = self.session.get(url)
        return response.json()

    def delete_use_manual_chat(self, contact_id):
        """取消手动聊天模式"""
        url = self.HOST + f"/api/v2/bots/{self.bot_id}/chats/{contact_id}/useManualChat"
        response = self.session.delete(url)
        return response.json()

    def add_user_tag(self, contact_id, tag_id):
        """设置用户标签"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/tags/{tag_id}"
        response = self.session.put(url)
        return response.json()

    def delete_user_tag(self, contact_id, tag_id):
        """删除用户标签"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/tags/{tag_id}"
        response = self.session.delete(url)
        return response.json()

    def mark_as_read(self, contact_id, message_id):
        """标记消息为已读"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/markAsRead"
        data = {"messageId": message_id}
        response = self.session.put(url, json=data)
        return response.json()

    def add_follow_up(self, contact_id):
        """关注用户"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/followUp"
        response = self.session.put(url)
        return response.json()

    def delete_follow_up(self, contact_id):
        """取消关注用户"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/followUp"
        response = self.session.delete(url)
        return response.json()

    def resolve(self, contact_id):
        """标记为已处理"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/done"
        response = self.session.put(url)
        return response.json()

    def remark(self, contact_id, nickname):
        """设置备注"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/nickname"
        data = {
            "nickname": nickname
        }
        response = self.session.put(url, json=data)
        return response.json()

    def pin(self, contact_id):
        """会话置顶"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/pin"
        response = self.session.put(url)
        return response.json()

    def unpin(self, contact_id):
        """取消会话置顶"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/pin"
        response = self.session.delete(url)
        return response.json()

    def content_preview(self, content_hash):
        """获取聊天图片"""
        url = f"https://chat-content.line.biz/bot/{self.bot_id}/{content_hash}"
        response = self.session.get(url)
        return response.content

    def profile_preview(self, content_hash):
        """获取联系资料图片"""
        url = f"https://profile.line-scdn.net/{content_hash}"
        response = self.session.get(url)
        return response.content

    def stickers(self, next_token=""):
        """贴纸列表"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/stickers/owned"
        params = {
            "nextToken": next_token
        }
        response = self.session.get(url, params=params)
        return response.json()

    def card_type_messages(self, limit=25):
        """卡片消息列表"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/cardTypeMessages"
        params = {
            "limit": limit
        }
        response = self.session.get(url, params=params)
        return response.json()

    def coupons(self, page=1, page_size=25):
        """优惠券列表"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/coupons"
        params = {
            "page": page,
            "pageSize": page_size
        }
        response = self.session.get(url, params=params)
        return response.json()

    def save_replies(self, query="", sort_key="CREATED_AT", page=1, page_size=25, exclude_username_placeholder=False):
        """标准回复列表"""
        url = self.HOST + f"/api/v2/bots/{self.bot_id}/savedReplies"
        params = {
            "query": query,
            "sortKey": sort_key,
            "pageSize": page_size,
            "page": page,
            "excludeUsernamePlaceholder": exclude_username_placeholder
        }
        response = self.session.get(url, params=params)
        return response.json()

    def set_typing(self, contact_id):
        """设置输入状态"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/chats/{contact_id}/typing"
        response = self.session.put(url)
        return response.json()

    @classmethod
    def make_send_id(cls, contact_id):
        return "_".join([contact_id, str(int(time.time() * 1000)), str(int(random.random() * 1e8))])

    def uoload_file(self, contact_id, file):
        """上传待发送文件"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/messages/{contact_id}/uploadFile"
        files = {
            "file": file
        }
        response = self.session.post(url, files=files)
        return response.json()

    def bulk_send_files(self, contact_id, data):
        """批量发送文件"""
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/messages/{contact_id}/bulkSendFiles"
        response = self.session.post(url, json=data)
        return response.json()

    def send(self, *args, **kwargs):
        """发送消息"""
        if "emojis" in kwargs:
            emojis = kwargs.get("emojis")
            if emojis is not None:
                if not isinstance(emojis, list):
                    raise TypeError("emojis must be a list.")

                if not len(emojis) > 0:
                    raise ValueError("emojis length can't be 0.")

                kwargs["text"] = re.sub("\[EM:([\w\d]+),id=([\w\d]+)\]", "$", kwargs["text"])
            else:
                kwargs.pop("emojis")

        if "quoteToken" in kwargs:
            quote_token = kwargs.get("quoteToken")
            if quote_token is not None:
                if not isinstance(quote_token, str):
                    raise TypeError("quoteToken must be a str.")
            else:
                kwargs.pop("quoteToken")

        contact_id = kwargs.pop("contact_id")
        url = self.HOST + f"/api/v1/bots/{self.bot_id}/messages/{contact_id}/send"
        send_id = self.make_send_id(contact_id)
        data = {
            "sendId": send_id,
            **kwargs
        }
        response = self.session.post(url, json=data)
        return {
            "send_id": send_id,
            **response.json(),
        }

    @staticmethod
    def manual_chat_mode(f):
        def wrapper(self, *args, **kwargs):
            if "contact_id" not in kwargs:
                raise ValueError("Missing required argument: contact_id")

            self.set_use_manual_chat(kwargs["contact_id"])
            data = f(self, *args, **kwargs)
            self.delete_use_manual_chat(kwargs["contact_id"])
            return data

        return wrapper

    @manual_chat_mode
    def send_file_msg(self, contact_id, file):
        """发送文件"""
        send_id = self.make_send_id(contact_id)
        content_message_token = self.uoload_file(contact_id, file)["contentMessageToken"]
        data = {"items": [{"contentMessageToken": content_message_token, "sendId": send_id}]}
        return {
            "send_id": send_id,
            **self.bulk_send_files(
                contact_id=contact_id,
                data=data
            )
        }

    @manual_chat_mode
    def send_text_msg(self, contact_id, text, escape=False, quote_token=None):
        """发送文本消息"""
        return self.send(**{
            "type": "text",
            "contact_id": contact_id,
            "text": text,
            "emojis": self.extract_emojis(text) if not escape else None,
            "quoteToken": quote_token
        })

    @manual_chat_mode
    def send_sticker_msg(self, contact_id, package_id, sticker_id, quote_token=None):
        """发送表情包消息"""
        return self.send(**{
            "type": "sticker",
            "contact_id": contact_id,
            "stickerId": sticker_id,
            "packageId": package_id,
            "quoteToken": quote_token
        })

    @manual_chat_mode
    def send_card_msg(self, contact_id, card_type_message_id):
        """发送卡片消息"""
        return self.send(**{
            "type": "cardType",
            "contact_id": contact_id,
            "cardTypeMessageId": card_type_message_id
        })

    @manual_chat_mode
    def send_call_msg(self, contact_id):
        """发送语音聊天邀请"""
        return self.send(**{
            "type": "callGuide",
            "contact_id": contact_id,
        })

    def sse(self, token, last_event_id=None, device_type="", client_type="PC", ping_secs=60):
        """sse事件"""
        url = "https://chat-streaming-api.line.biz/api/v2/sse"
        params = {
            "token": token,
            "deviceType": device_type,
            "clientType": client_type,
            "pingSecs": ping_secs,
            "lastEventId": last_event_id
        }
        response = self.session.get(url, params=params, stream=True)
        for event_data in response.iter_lines(delimiter=b"\n\n"):
            if event_data != b"":
                yield event_data

    def handle(self, event=None, sub_event=None):
        def wrapper(f):
            if event is not None:
                if not isinstance(event, str):
                    raise TypeError("event must be a str.")

            if sub_event is not None:
                if not isinstance(sub_event, str):
                    raise TypeError("sub_event must be a str.")

            event_name = None
            if event is not None and sub_event is not None:
                event_name = f"{event}-{sub_event}"
            elif event is not None and sub_event is None:
                event_name = event
            elif event is None and sub_event is not None:
                raise ValueError("sub_event need a event.")
            else:
                self.event_emitter.on("event", f)

            if event_name is not None:
                self.event_emitter.on(event_name, f)

        return wrapper

    def run(self):
        logger.info(f"Account: %s" % self.account["name"])
        logger.info(f"Bot: %s" % self.bot["name"])
        logger.info(f"Message listening...")
        while True:
            try:
                streaming_api_token = self.streaming_api_token()
                logger.debug(streaming_api_token)

                for event_data in self.sse(
                        token=streaming_api_token["streamingApiToken"],
                        last_event_id=streaming_api_token.get("lastEventId"),
                        device_type=self.device_type,
                        client_type=self.client_type,
                        ping_secs=self.ping_secs
                ):
                    event_data = event_data.decode()
                    event_data_part = event_data.split("\n")
                    id = event_data_part[0].replace("id:", "")
                    event_name = event_data_part[1].replace("event:", "")
                    data = event_data_part[2].replace("data:", "")

                    if data == "ping":
                        data = "{}"

                    event = {
                        "id": id,
                        "event": event_name,
                        "data": json.loads(data)
                    }
                    logger.debug(event)

                    self.event_emitter.emit("event", self, event)
                    self.event_emitter.emit(event_name, self, event)
                    if event["event"] and "subEvent" in event["data"]:
                        event_name = "%s-%s" % (event["event"], event["data"]["subEvent"])
                        self.event_emitter.emit(event_name, self, event)

                    if event["event"] == "fail":
                        if event["data"]["subEvent"] == "invalid_token":
                            raise InvalidTokenException

            except InvalidTokenException as e:
                logger.error(e)

            except Exception as e:
                logger.error(e)

            time.sleep(self.streaming_token_retries)
